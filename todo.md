## TODO before release/PR

- [ ] See whether Travis builds work
- [X] Remove debugger statements also in webcrypto-shim
- [ ] Verify dealing with token expiration.
- [X] Manual smoke test
- [ ] @chris Check If OK to not use PhantomJS. I think yes
- [x] Make an ES5 commonJS build or AMD -> npm?
- [X] consider removing detailed comments...
- [x] remove/refactor none essential test code. -> did extended test suite
- [x] Look at todos in code base
- [x] Add unit test so that token with alg: none will not be a security issue
- [x] Automatic fallback to use no-validate when enabled cases.
      Perhaps allow for server validation?
- [x] Add test for using no-validate fallback
- [x] Will use jspm 0.16 for tests and npm commonJS browserify for example.
- [x] Check about the server key incompatibility
- [x] Test MS browsers. This will require installing node on win or use a
       cloud service
- [x] Remove jquery
- [x] Look into crypto downloads of jspm, what are they for?
       https://github.com/jspm/jspm-cli/issues/1067
       These were dragged in by npm:sjcl
- [ ] Ensure webcrypto-shim to be versioned and perhaps not from master.
- [x] Remove dependencies or have as dev/test dependencies:
         [x] angular-mocks,
         [x] babel*?
         [x] jquery
         [x] capaj/jspm-hot-reloader" seems like this is not really needed here..
         [x] sjcl
       True dependencies are:
         bows, base64-js, text-encode-lite, webcrypto-shim, tiny-emitter
         for plain.js: q
         for angular: angular

## Review items:

### difference between session encryption in web crypto and legacy

connect.js stores:
1. the secret in cookie `'anvil.connect'` with one hour expiration
2. the encrypted value in `localStorage['anvil.connect']`

Now with legacy (sjcl) encryption the encrypted value contains some information
about the crypto algorithm used:
```
# Line breaks inserted for readibility
encrypted: '{
  "iv":"m9YjZ/HOrjVEhrtrIvnngw==",
   "v":1,
"iter":1000,
  "ks":128,
  "ts":64,
  "mode":"ccm",
  "adata":"",
  "cipher":"aes",
  "salt":"/9cYqWfQ7mU=",
  "ct":"ZcXucBukW58GwjCVhvg="}'
```

The secret is an sha256 hex value of a random number:
```
  secret: '88e2a5baf63abbab21b422133a7dc4716f7030d7dab48707e27c477b2d3a9d73',
```

Now the webcrypto API calls out an initialization vector (iv) which is stored
however as component of the secret (which also contains the random number)

So we have
```
  secret: '4VeyLKr0tJcMVAMS2cNRZw==.8919jCYXdb6tu7p6s4SPkg==',
  encrypted: '3tcxKrp65OvwYdXp2oPi/g=='
```

where secret is of the form <iv>.<key> where
* iv was generated by crypto.getRandomValues(new Uint8Array(16))
* key is the exported crypto key
```
generateEncryptionKey () {
  return crypto.subtle.generateKey(
    {name: 'AES-CBC', length: 128},
    true,
    ['encrypt', 'decrypt']
  ).then( key => {
    return crypto.subtle.exportKey(
      'raw', key)
  })
```
Currently the webcrypto implementation stores the (exported) key and iv
as the secret whereas sjcl stores the key with the encrypted data.

todo: How to do this best?

## Should be elsewhere:

Resources used:
* [RFC 7517 - JSON Web Key (JWK)](https://tools.ietf.org/html/rfc7517#ref-JWT)
* [RFC 7519 - JSON Web Token (JWT)](https://tools.ietf.org/html/rfc7519#ref-JWS)
* [RFC 7515 - JSON Web Signature (JWS)](https://tools.ietf.org/html/rfc7515#appendix-A.1)


## Issue/Question about keys used.

* [Webcrypto API · Issue #7 · anvilresearch/connect-js](https://github.com/anvilresearch/connect-js/issues/7)

* [test for pem-jwk](issue https://github.com/dannycoates/pem-jwk/issues/2)
Comment here:

Related workspaces are at
/Users/dev/code/experiment/rsa-pem-to-jwk
/Users/dev/code/experiment/pem-jwk
